# Design System Package - Cursor Rules

You are an expert in building design systems using Radix UI primitives and vanilla-extract styling. Follow these strict architectural patterns and requirements.

## Core Architecture Requirements

### 1. Component Foundation - MANDATORY
- **ALWAYS** use Radix UI primitives as the foundation for ALL interactive components
- **NEVER** build interactive components from scratch - extend Radix primitives only
- Leverage Radix's built-in accessibility features, keyboard navigation, and focus management
- Use Radix's compound component patterns for complex UI elements

### 2. Styling System - MANDATORY
- **EXCLUSIVELY** use vanilla-extract for all styling - no exceptions
- **NEVER** use CSS-in-JS libraries other than vanilla-extract (no styled-components, emotion, etc.)
- Organize styles using vanilla-extract's `.css.ts` files
- Use vanilla-extract recipes for component variants and states
- Implement design tokens using vanilla-extract's contract system

### 3. Dark Mode Support - REQUIRED
- **EVERY** component must support both light and dark themes
- Use vanilla-extract's theme contracts with CSS custom properties
- Define comprehensive theme contracts for consistent color usage
- Implement theme switching without FOUC (Flash of Unstyled Content)
- Test all components in both light and dark modes before completion

### 4. Responsive Design - MANDATORY
- **ALL** components must be responsive by default
- Use vanilla-extract's responsive utilities and breakpoints
- Implement mobile-first responsive design approach
- Support breakpoints: mobile (320px+), tablet (768px+), desktop (1024px+)
- Ensure touch-friendly interactions on mobile devices

## Implementation Pattern

### Component Structure Template
```typescript
// ✅ REQUIRED: Follow this exact pattern
import * as RadixPrimitive from '@radix-ui/react-[component]';
import { recipe, type RecipeVariants } from '@vanilla-extract/recipes';
import { clsx } from 'clsx';
import { forwardRef } from 'react';
import { theme } from '../styles/theme.css';

// Define styles with vanilla-extract recipes
export const componentStyles = recipe({
  base: {
    // Base styles with theme contracts
    backgroundColor: theme.colors.background,
    color: theme.colors.foreground,
    borderRadius: theme.radii.md,
    fontFamily: theme.fonts.body,
    
    // Responsive styles using theme breakpoints
    '@media': {
      [theme.breakpoints.tablet]: {
        // Tablet-specific styles
      },
      [theme.breakpoints.desktop]: {
        // Desktop-specific styles
      }
    }
  },
  variants: {
    variant: {
      primary: { 
        backgroundColor: theme.colors.primary,
        color: theme.colors.primaryForeground 
      },
      secondary: { 
        backgroundColor: theme.colors.secondary,
        color: theme.colors.secondaryForeground 
      }
    },
    size: {
      sm: { 
        padding: theme.space[2],
        fontSize: theme.fontSizes.sm 
      },
      md: { 
        padding: theme.space[3],
        fontSize: theme.fontSizes.base 
      },
      lg: { 
        padding: theme.space[4],
        fontSize: theme.fontSizes.lg 
      }
    }
  },
  defaultVariants: {
    variant: 'primary',
    size: 'md'
  }
});

type ComponentVariants = RecipeVariants<typeof componentStyles>;

// Extend Radix component with proper TypeScript types
export interface ComponentProps 
  extends React.ComponentPropsWithoutRef<typeof RadixPrimitive.Root>,
          ComponentVariants {}

export const Component = forwardRef<
  React.ElementRef<typeof RadixPrimitive.Root>,
  ComponentProps
>(({ className, variant, size, ...props }, ref) => (
  <RadixPrimitive.Root
    ref={ref}
    className={clsx(componentStyles({ variant, size }), className)}
    {...props}
  />
));

Component.displayName = 'Component';
```

### Theme System Requirements
```typescript
// theme.css.ts - REQUIRED structure
import { createTheme, createThemeContract } from '@vanilla-extract/css';

// Define theme contract
export const themeContract = createThemeContract({
  colors: {
    // Semantic color tokens
    background: null,
    foreground: null,
    primary: null,
    primaryForeground: null,
    secondary: null,
    secondaryForeground: null,
    accent: null,
    accentForeground: null,
    destructive: null,
    destructiveForeground: null,
    // State colors
    border: null,
    input: null,
    ring: null,
    // Dark mode variants
    backgroundDark: null,
    foregroundDark: null
  },
  spacing: {
    1: null, 2: null, 3: null, 4: null, 
    6: null, 8: null, 12: null, 16: null
  },
  fontSizes: {
    xs: null, sm: null, base: null, 
    lg: null, xl: null, '2xl': null
  },
  radii: {
    sm: null, md: null, lg: null, full: null
  },
  breakpoints: {
    tablet: null,
    desktop: null
  }
});

// Light theme implementation
export const lightTheme = createTheme(themeContract, {
  colors: {
    background: 'hsl(0 0% 100%)',
    foreground: 'hsl(222.2 84% 4.9%)',
    primary: 'hsl(222.2 47.4% 11.2%)',
    primaryForeground: 'hsl(210 40% 98%)',
    // ... complete color definitions
  },
  // ... complete theme implementation
});

// Dark theme implementation
export const darkTheme = createTheme(themeContract, {
  colors: {
    background: 'hsl(222.2 84% 4.9%)',
    foreground: 'hsl(210 40% 98%)',
    primary: 'hsl(210 40% 98%)',
    primaryForeground: 'hsl(222.2 47.4% 11.2%)',
    // ... complete dark color definitions
  },
  // ... complete dark theme implementation
});

export const theme = themeContract;
```

## File Organization Standard
```
packages/ui/src/
├── components/
│   ├── button/
│   │   ├── index.ts          # Re-exports
│   │   ├── button.tsx        # Component implementation
│   │   └── button.css.ts     # Vanilla-extract styles
│   ├── dialog/
│   │   ├── index.ts
│   │   ├── dialog.tsx
│   │   └── dialog.css.ts
├── styles/
│   ├── theme.css.ts          # Theme contracts and implementations
│   ├── global.css.ts         # Global styles
│   ├── tokens.css.ts         # Design tokens
│   └── utils.css.ts          # Style utilities
├── providers/
│   └── theme-provider.tsx    # Theme context provider
└── index.ts                  # Package exports
```

## Quality Standards

### Accessibility Checklist - MANDATORY
- [ ] Leverages Radix's built-in accessibility features
- [ ] Proper ARIA labels and descriptions provided
- [ ] Keyboard navigation functions correctly
- [ ] Focus management works as expected
- [ ] Color contrast meets WCAG AA standards (4.5:1 minimum)
- [ ] Supports screen readers
- [ ] Respects `prefers-reduced-motion`

### Interactive States - REQUIRED
```typescript
// All interactive components must include these states
const interactiveStyles = {
  // Base state
  cursor: 'pointer',
  transition: 'all 0.2s ease-in-out',
  
  // Hover state
  ':hover': {
    backgroundColor: theme.colors.primaryHover,
    transform: 'translateY(-1px)'
  },
  
  // Focus state
  ':focus-visible': {
    outline: `2px solid ${theme.colors.ring}`,
    outlineOffset: '2px'
  },
  
  // Active state
  ':active': {
    transform: 'translateY(0)'
  },
  
  // Disabled state
  ':disabled': {
    opacity: 0.5,
    cursor: 'not-allowed',
    pointerEvents: 'none'
  }
};
```

## Strict Prohibitions

### ❌ NEVER DO THESE
- Use CSS-in-JS libraries other than vanilla-extract
- Create interactive components without Radix primitives
- Hardcode colors, spacing, or typography values
- Skip responsive design implementation
- Ignore dark mode requirements
- Use inline styles or style props
- Bypass Radix accessibility features
- Create components that don't follow the established pattern

### ❌ FORBIDDEN IMPORTS
```typescript
// These imports are FORBIDDEN
import styled from 'styled-components';     // ❌
import { css } from '@emotion/react';       // ❌
import { makeStyles } from '@material-ui/core'; // ❌
```

## Development Workflow - MANDATORY PROCESS

### Phase 1: Planning & Preparation
1. **Feature Conflict Check**: ALWAYS verify no existing overlapping functionality exists
2. **Branch Creation**: Create a new feature branch following naming convention: `feat/component-name` or `feat/component-enhancement`
3. **Radix Primitive Investigation**: Research if Radix UI provides the required functionality
   - If available: Plan to import and style Radix primitive
   - If unavailable: Study similar Radix implementations to maintain consistency with Radix philosophy

### Phase 2: Architecture & Design Pattern Compliance
4. **Atomic Design Pattern**: MANDATORY adherence to atomic design principles
   - Atoms: Basic building blocks (buttons, inputs, labels)
   - Molecules: Simple combinations of atoms (form groups, navigation items)
   - Organisms: Complex UI components (forms, headers, modals)
   - Templates: Page-level layouts
   - Pages: Specific instances of templates

### Phase 3: Implementation
5. **Component Development**:
   - Implement functionality according to established patterns
   - Apply styling using vanilla-extract exclusively
   - Ensure responsive design and dark mode support
   - Follow TypeScript typing standards

### Phase 4: Documentation & Testing
6. **Storybook Creation**: MANDATORY for every component
   - Write comprehensive component stories
   - Include design purpose and usage guidelines
   - Maintain change history documentation
   - Create detailed Args configuration with Controls for all dynamic/user-input props
   - Document all use cases and variants

### Phase 5: Quality Assurance
7. **Test Implementation**: Write comprehensive test cases covering:
   - Component functionality
   - User interactions
   - Accessibility compliance
   - Responsive behavior
   - Dark/light mode compatibility

### Phase 6: Version Control
8. **Commit Standards**: Create meaningful commits for each workflow phase:
   - `feat: add [component] foundation`
   - `style: implement [component] styling with vanilla-extract`
   - `docs: add [component] storybook stories and documentation`
   - `test: add [component] test suite`
   - `refactor: optimize [component] implementation`

### Phase 7: Quality Gate
9. **Workflow Compliance Check**: After each phase, verify:
   - [ ] No workflow steps were skipped
   - [ ] All requirements are met before proceeding
   - [ ] Rework incomplete items to maintain workflow integrity

### Before Starting Any Component - EXPANDED CHECKLIST
1. **Duplication Analysis**: Search existing components for similar functionality
2. **Radix Research**: Check Radix UI documentation for primitive availability
3. **Atomic Classification**: Determine component's position in atomic design hierarchy
4. **Branch Strategy**: Create appropriately named feature branch
5. **Dependencies Audit**: Identify required Radix primitives and vanilla-extract patterns
6. **Documentation Planning**: Outline Storybook stories and component documentation
7. **Testing Strategy**: Plan test scenarios and edge cases

### Component Completion Checklist - ENHANCED
#### Technical Implementation
- [ ] Built on appropriate Radix primitive (or follows Radix philosophy if custom)
- [ ] Styled exclusively with vanilla-extract
- [ ] Supports both light and dark themes
- [ ] Responsive across all breakpoints
- [ ] Proper TypeScript types and interfaces
- [ ] All interactive states implemented
- [ ] Accessibility features verified
- [ ] Performance optimized
- [ ] Follows established file organization
- [ ] Includes proper exports in index.ts

#### Documentation & Stories
- [ ] Storybook stories created with comprehensive examples
- [ ] Component purpose and design rationale documented
- [ ] Usage guidelines and best practices documented
- [ ] Change history maintained
- [ ] Args configuration with Controls for dynamic props
- [ ] All use cases and variants demonstrated

#### Testing & Quality
- [ ] Unit tests covering functionality
- [ ] Integration tests for user interactions
- [ ] Accessibility tests implemented
- [ ] Visual regression tests added
- [ ] Performance benchmarks verified

#### Process Compliance
- [ ] Followed atomic design classification
- [ ] No functionality duplication with existing components
- [ ] Appropriate git commits created
- [ ] Workflow compliance verified at each phase
- [ ] All phases completed without shortcuts

## Testing Requirements - COMPREHENSIVE COVERAGE

### Test Categories - ALL MANDATORY
1. **Functional Testing**
   - Component renders correctly with default props
   - All prop variations work as expected
   - Event handlers trigger correctly
   - State management functions properly

2. **Visual Testing**
   - Component appearance in light mode
   - Component appearance in dark mode
   - Responsive behavior at all breakpoints (mobile, tablet, desktop)
   - All variant combinations render correctly

3. **Interaction Testing**
   - Mouse interactions (click, hover, drag)
   - Keyboard navigation and shortcuts
   - Touch interactions on mobile devices
   - Focus management and tab order

4. **Accessibility Testing**
   - Screen reader compatibility
   - ARIA attributes and labels
   - Color contrast ratios (WCAG AA compliance)
   - Focus indicators visibility
   - Keyboard-only navigation

5. **Integration Testing**
   - Component works within different layouts
   - Plays well with other design system components
   - Theme switching functionality
   - Context provider dependencies

### Testing Standards by Component Type

#### Atoms (Basic Components)
```typescript
// Example test structure for atoms
describe('Button Component', () => {
  describe('Functionality', () => {
    test('renders with default props')
    test('handles click events')
    test('supports disabled state')
  });
  
  describe('Variants', () => {
    test('renders primary variant correctly')
    test('renders secondary variant correctly')
    test('renders destructive variant correctly')
  });
  
  describe('Accessibility', () => {
    test('has proper ARIA attributes')
    test('supports keyboard navigation')
    test('meets color contrast requirements')
  });
  
  describe('Theming', () => {
    test('renders correctly in light mode')
    test('renders correctly in dark mode')
  });
});
```

#### Molecules/Organisms (Complex Components)
- Include additional tests for component composition
- Test internal state management
- Verify complex user workflows
- Test error handling and edge cases

### Test Implementation Requirements
- **Jest + React Testing Library**: Primary testing framework
- **@testing-library/jest-dom**: Enhanced DOM matchers
- **@testing-library/user-event**: User interaction simulation
- **jest-axe**: Accessibility testing
- **Storybook Test Runner**: Visual regression testing

### Performance Testing
- Component rendering performance
- Memory usage optimization
- Bundle size impact assessment
- Re-render efficiency testing

## Storybook Documentation Standards

### Story Structure - MANDATORY FORMAT
```typescript
import type { Meta, StoryObj } from '@storybook/react';
import { Component } from './component';

const meta: Meta<typeof Component> = {
  title: 'Design System/[Atomic Level]/Component Name',
  component: Component,
  parameters: {
    docs: {
      description: {
        component: `
## Purpose
Brief description of component's design purpose and when to use it.

## Usage Guidelines
- When to use this component
- When NOT to use this component
- Best practices and recommendations

## Change History
- v1.0.0: Initial implementation
- v1.1.0: Added new variant
- v1.2.0: Enhanced accessibility features
        `
      }
    }
  },
  argTypes: {
    // Detailed Args configuration for ALL dynamic props
    variant: {
      control: { type: 'select' },
      options: ['primary', 'secondary', 'destructive'],
      description: 'Visual style variant of the component'
    },
    size: {
      control: { type: 'radio' },
      options: ['sm', 'md', 'lg'],
      description: 'Size variation of the component'
    },
    disabled: {
      control: { type: 'boolean' },
      description: 'Disables component interaction'
    }
    // Include ALL user-configurable props with detailed controls
  }
};

export default meta;
type Story = StoryObj<typeof meta>;

// Default story showing primary use case
export const Default: Story = {
  args: {
    variant: 'primary',
    size: 'md',
    children: 'Button Text'
  }
};

// Stories for ALL use cases and variants
export const AllVariants: Story = {
  render: () => (
    <div style={{ display: 'flex', gap: '1rem' }}>
      <Component variant="primary">Primary</Component>
      <Component variant="secondary">Secondary</Component>
      <Component variant="destructive">Destructive</Component>
    </div>
  )
};

export const AllSizes: Story = {
  render: () => (
    <div style={{ display: 'flex', gap: '1rem', alignItems: 'center' }}>
      <Component size="sm">Small</Component>
      <Component size="md">Medium</Component>
      <Component size="lg">Large</Component>
    </div>
  )
};

export const DisabledState: Story = {
  args: {
    disabled: true,
    children: 'Disabled Button'
  }
};

// Interactive story for testing
export const Playground: Story = {
  args: {
    variant: 'primary',
    size: 'md',
    children: 'Interactive Button'
  }
};
```

### Documentation Requirements
- **Component Purpose**: Clear explanation of design intent
- **Usage Guidelines**: When and how to use the component
- **Change History**: Version tracking and migration notes
- **Interactive Controls**: All dynamic props must have Storybook controls
- **Use Case Coverage**: Stories for every intended use case
- **Accessibility Notes**: Screen reader and keyboard interaction documentation

Remember: This is a design system package that others will depend on. Every component must be bulletproof, accessible, and follow these patterns exactly. The workflow is non-negotiable - shortcuts compromise the entire system's quality and consistency.